#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
File System Watcher - Monitors a drop folder for new files.

When files are added to the Inbox folder, this watcher:
1. Copies the file to Needs_Action
2. Creates a metadata .md file with file info
3. Triggers Claude Code to process it

Usage:
    python filesystem_watcher.py /path/to/vault
"""

import sys
import time
import shutil
import hashlib
from pathlib import Path
from datetime import datetime
from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler, FileCreatedEvent

from base_watcher import BaseWatcher


class DropFolderHandler(FileSystemEventHandler):
    """Handles file drop events and creates action files."""
    
    def __init__(self, vault_path: str):
        """
        Initialize the handler.
        
        Args:
            vault_path: Path to the Obsidian vault
        """
        self.vault_path = Path(vault_path)
        self.inbox = self.vault_path / 'Inbox'
        self.needs_action = self.vault_path / 'Needs_Action'
        self.processed_hashes = set()
        
        # Ensure folders exist
        self.inbox.mkdir(parents=True, exist_ok=True)
        self.needs_action.mkdir(parents=True, exist_ok=True)
    
    def _get_file_hash(self, filepath: Path) -> str:
        """Calculate MD5 hash of file for deduplication."""
        hash_md5 = hashlib.md5()
        with open(filepath, "rb") as f:
            for chunk in iter(lambda: f.read(4096), b""):
                hash_md5.update(chunk)
        return hash_md5.hexdigest()
    
    def on_created(self, event):
        """Handle file creation events."""
        if event.is_directory:
            return
        
        source = Path(event.src_path)
        
        # Skip hidden files and temp files
        if source.name.startswith('.') or source.suffix == '.tmp':
            return
        
        # Check for duplicates
        file_hash = self._get_file_hash(source)
        if file_hash in self.processed_hashes:
            return
        
        self.processed_hashes.add(file_hash)
        
        # Copy file to Needs_Action
        dest = self.needs_action / f'FILE_{source.name}'
        try:
            shutil.copy2(source, dest)
            self.create_metadata(source, dest, file_hash)
            print(f"[{datetime.now().isoformat()}] Processed: {source.name}")
        except Exception as e:
            print(f"[{datetime.now().isoformat()}] Error processing {source.name}: {e}")
    
    def create_metadata(self, source: Path, dest: Path, file_hash: str):
        """Create a metadata markdown file for the dropped file."""
        meta_path = dest.with_suffix('.md')
        
        # Determine file type based on extension
        file_type = {
            '.txt': 'text',
            '.md': 'markdown',
            '.pdf': 'document',
            '.doc': 'document',
            '.docx': 'document',
            '.xls': 'spreadsheet',
            '.xlsx': 'spreadsheet',
            '.csv': 'data',
            '.jpg': 'image',
            '.jpeg': 'image',
            '.png': 'image',
        }.get(source.suffix.lower(), 'unknown')
        
        content = f'''---
type: file_drop
original_name: {source.name}
size: {source.stat().st_size}
size_formatted: {self._format_size(source.stat().st_size)}
file_hash: {file_hash}
dropped: {datetime.now().isoformat()}
status: pending
priority: normal
---

# File Drop for Processing

## File Information
- **Original Name:** {source.name}
- **File Type:** {file_type}
- **Size:** {self._format_size(source.stat().st_size)}
- **Dropped At:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

## Content
*Review the attached file and take appropriate action*

## Suggested Actions
- [ ] Review file content
- [ ] Categorize and file appropriately
- [ ] Take any required action
- [ ] Move to /Done when complete

---
*Generated by File System Watcher v0.1*
'''
        meta_path.write_text(content)
    
    def _format_size(self, size: int) -> str:
        """Format file size in human-readable format."""
        for unit in ['B', 'KB', 'MB', 'GB']:
            if size < 1024:
                return f"{size:.1f} {unit}"
            size /= 1024
        return f"{size:.1f} TB"


class FileSystemWatcher(BaseWatcher):
    """File system watcher using watchdog for efficient monitoring."""
    
    def __init__(self, vault_path: str, check_interval: int = 5):
        """
        Initialize the file system watcher.
        
        Args:
            vault_path: Path to the Obsidian vault
            check_interval: Check interval (not used with watchdog, but kept for API compatibility)
        """
        super().__init__(vault_path, check_interval)
        self.handler = DropFolderHandler(vault_path)
    
    def check_for_updates(self) -> list:
        """
        This method is not used with watchdog (event-driven).
        Returns empty list.
        """
        return []
    
    def create_action_file(self, item) -> Path:
        """
        This method is not used with watchdog (event-driven).
        """
        pass
    
    def run(self):
        """Run the watchdog observer."""
        self.logger.info(f'Starting FileSystemWatcher')
        self.logger.info(f'Watching folder: {self.handler.inbox}')
        
        observer = Observer()
        observer.schedule(self.handler, str(self.handler.inbox), recursive=False)
        observer.start()
        
        try:
            while True:
                time.sleep(1)
        except KeyboardInterrupt:
            observer.stop()
            self.logger.info('Watcher stopped')
        observer.join()


def main():
    """Main entry point."""
    if len(sys.argv) < 2:
        print("Usage: python filesystem_watcher.py /path/to/vault")
        print("\nExample:")
        print("  python filesystem_watcher.py ./AI_Employee_Vault")
        sys.exit(1)
    
    vault_path = sys.argv[1]
    
    if not Path(vault_path).exists():
        print(f"Error: Vault path does not exist: {vault_path}")
        sys.exit(1)
    
    watcher = FileSystemWatcher(vault_path)
    watcher.run()


if __name__ == '__main__':
    main()
